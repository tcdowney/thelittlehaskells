// NOTE (COPYRIGHT INFORMATION): drawCircle and drawLine functions adapted from
// the Adafruit-ST7735-Library provided in the lab manual.

#include <stm32f10x.h>
#include <stm32f10x_rcc.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_spi.h>
#include "spidma.h"
#include "lcdma.h"
#include "bmp.h"


// Timing code -------------------------------------------------------------

static __IO uint32_t TimingDelay;

void Delay(uint32_t nTime) {
  TimingDelay = nTime;
  while(TimingDelay != 0);
}

void SysTick_Handler(void) {
  if (TimingDelay != 0x00)
    TimingDelay--;
}

// Utility functions (for drawLine function) -------------------------------
int abs(int x) {
  if (x < 0)
    return -1*x;
  else
    return x;
}

void swap (int *x, int *y) {
  int temp = *x;
  *x = *y;
  *y = temp;
}

// command buffer structure ------------------------------------------------

struct ST7735_cmdBuf {
  uint8_t command;   // ST7735 command byte
  uint8_t delay;     // ms delay after
  uint8_t len;       // length of parameter data
  uint8_t data[16];  // parameter data
};

// Initialization commands -------------------------------------------------

static const struct ST7735_cmdBuf initializers[] = {
  // SWRESET Software reset
  {0x01, 150, 0, 0},
  // SLPOUT Leave sleep mode
  {0x11, 150, 0, 0},
  // FRMCTR1 , FRMCTR2 Frame Rate configuration -- Normal mode , idle
  // frame rate = fosc / (1 x 2 + 40) * (LINE + 2C + 2D)
  {0xB1, 0, 3, {0x01, 0x2C, 0x2D}},
  {0xB2, 0, 3, {0x01, 0x2C, 0x2D}},
  // FRMCTR3 Frame Rate configureation -- partial mode
  {0xB3, 0, 6, {0x01, 0x2C, 0x2D, 0x01, 0x2C, 0x2D}},
  // INVCTR Display inversion (no inversion )
  {0xB4 , 0, 1, {0x07}},
  // PWCTR1 Power control -4.6V, Auto mode
  {0xC0, 0, 3, {0xA2, 0x02, 0x84}},
  // PWCTR2 Power control VGH25 2.4C, VGSEL -10, VGH = 3 * AVDD
  {0xC1, 0, 1, {0xC5}},
  // PWCTR3 Power control , opamp current smal , boost frequency
  {0xC2, 0, 2, {0x0A, 0x00}},
  // PWCTR4 Power control , BLK /2, opamp current small and medium low
  {0xC3, 0, 2, {0x8A, 0x2A}},
  // PWRCTR5 , VMCTR1 Power control
  {0xC4, 0, 2, {0x8A , 0xEE}},
  {0xC5, 0, 1, {0x0E}},
  // INVOFF Don't invert display
  {0x20 , 0, 0, 0},
  // Memory access directions. row address /col address, bottom to
  // top refesh (10.1.27)
  {ST7735_MADCTL, 0, 1, {MADVAL(MADCTLGRAPHICS)}},
  // Color mode 16 bit (10.1.30
  {ST7735_COLMOD, 0, 1, {0x05}},
  // Column address set 0..127
  {ST7735_CASET, 0, 4, {0x00, 0x00, 0x00, 0x7F}},
  // Row address set 0..159
  {ST7735_RASET, 0, 4, {0x00, 0x00, 0x00, 0x9F}},
  // GMCTRP1 Gamma correction
  {0xE0, 0, 16, {0x02, 0x1C, 0x07, 0x12, 0x37, 0x32, 0x29, 0x2D,
		 0x29, 0x25, 0x2B, 0x39, 0x00, 0x01, 0x03, 0x10}},
  // GMCTRP2 Gamma Polarity correction
  {0xE1, 0, 16, {0x03, 0x1d, 0x07, 0x06, 0x2E, 0x2C, 0x29, 0x2D,
		 0x2E, 0x2E, 0x37, 0x3F, 0x00, 0x00, 0x02, 0x10}},
  // DISPON Display on
  {0x29, 100, 0, 0},
  // NORON Normal on
  {0x13, 10, 0, 0},
  // End
  {0, 0, 0, 0}
};

// Font used for writing text ---------------------------------------------

const uint8_t ASCII[] = {
  0x00, 0x00, 0x00, 0x00, 0x00,  // 0 
  0x3E, 0x5B, 0x4F, 0x5B, 0x3E,  // 1 
  0x3E, 0x6B, 0x4F, 0x6B, 0x3E,  // 2 
  0x1C, 0x3E, 0x7C, 0x3E, 0x1C,  // 3 
  0x18, 0x3C, 0x7E, 0x3C, 0x18,  // 4 
  0x1C, 0x57, 0x7D, 0x57, 0x1C,  // 5 
  0x1C, 0x5E, 0x7F, 0x5E, 0x1C,  // 6 
  0x00, 0x18, 0x3C, 0x18, 0x00,  // 7 
  0xFF, 0xE7, 0xC3, 0xE7, 0xFF,  // 8 
  0x00, 0x18, 0x24, 0x18, 0x00,  // 9 
  0xFF, 0xE7, 0xDB, 0xE7, 0xFF,  // 10
  0x30, 0x48, 0x3A, 0x06, 0x0E,  // 11
  0x26, 0x29, 0x79, 0x29, 0x26,  // 12
  0x40, 0x7F, 0x05, 0x05, 0x07,  // 13
  0x40, 0x7F, 0x05, 0x25, 0x3F,  // 14
  0x5A, 0x3C, 0xE7, 0x3C, 0x5A,  // 15
  0x7F, 0x3E, 0x1C, 0x1C, 0x08,  // 16
  0x08, 0x1C, 0x1C, 0x3E, 0x7F,  // 17
  0x14, 0x22, 0x7F, 0x22, 0x14,  // 18
  0x5F, 0x5F, 0x00, 0x5F, 0x5F,  // 19
  0x06, 0x09, 0x7F, 0x01, 0x7F,  // 20
  0x00, 0x66, 0x89, 0x95, 0x6A,  // 21
  0x60, 0x60, 0x60, 0x60, 0x60,  // 22
  0x94, 0xA2, 0xFF, 0xA2, 0x94,  // 23
  0x08, 0x04, 0x7E, 0x04, 0x08,  // 24
  0x10, 0x20, 0x7E, 0x20, 0x10,  // 25
  0x08, 0x08, 0x2A, 0x1C, 0x08,  // 26
  0x08, 0x1C, 0x2A, 0x08, 0x08,  // 27
  0x1E, 0x10, 0x10, 0x10, 0x10,  // 28
  0x0C, 0x1E, 0x0C, 0x1E, 0x0C,  // 29
  0x30, 0x38, 0x3E, 0x38, 0x30,  // 30
  0x06, 0x0E, 0x3E, 0x0E, 0x06,  // 31
  0x00, 0x00, 0x00, 0x00, 0x00,  // 32 space
  0x00, 0x00, 0x5F, 0x00, 0x00,  // 33 !
  0x00, 0x07, 0x00, 0x07, 0x00,  // 34 "
  0x14, 0x7F, 0x14, 0x7F, 0x14,  // 35 #
  0x24, 0x2A, 0x7F, 0x2A, 0x12,  // 36 $
  0x23, 0x13, 0x08, 0x64, 0x62,  // 37 %
  0x36, 0x49, 0x56, 0x20, 0x50,  // 38 &
  0x00, 0x08, 0x07, 0x03, 0x00,  // 39 '
  0x00, 0x1C, 0x22, 0x41, 0x00,  // 40 (
  0x00, 0x41, 0x22, 0x1C, 0x00,  // 41 )
  0x2A, 0x1C, 0x7F, 0x1C, 0x2A,  // 42 *
  0x08, 0x08, 0x3E, 0x08, 0x08,  // 43 +
  0x00, 0x80, 0x70, 0x30, 0x00,  // 44 ,
  0x08, 0x08, 0x08, 0x08, 0x08,  // 45 -
  0x00, 0x00, 0x60, 0x60, 0x00,  // 46 .
  0x20, 0x10, 0x08, 0x04, 0x02,  // 47 /
  0x3E, 0x51, 0x49, 0x45, 0x3E,  // 48 0
  0x00, 0x42, 0x7F, 0x40, 0x00,  // 49 1
  0x72, 0x49, 0x49, 0x49, 0x46,  // 50 2
  0x21, 0x41, 0x49, 0x4D, 0x33,  // 51 3
  0x18, 0x14, 0x12, 0x7F, 0x10,  // 52 4
  0x27, 0x45, 0x45, 0x45, 0x39,  // 53 5
  0x3C, 0x4A, 0x49, 0x49, 0x31,  // 54 6
  0x41, 0x21, 0x11, 0x09, 0x07,  // 55 7
  0x36, 0x49, 0x49, 0x49, 0x36,  // 56 8
  0x46, 0x49, 0x49, 0x29, 0x1E,  // 57 9
  0x00, 0x00, 0x14, 0x00, 0x00,  // 58 :
  0x00, 0x40, 0x34, 0x00, 0x00,  // 59 ;
  0x00, 0x08, 0x14, 0x22, 0x41,  // 60 <
  0x14, 0x14, 0x14, 0x14, 0x14,  // 61 =
  0x00, 0x41, 0x22, 0x14, 0x08,  // 62 >
  0x02, 0x01, 0x59, 0x09, 0x06,  // 63 ?
  0x3E, 0x41, 0x5D, 0x59, 0x4E,  // 64 @
  0x7C, 0x12, 0x11, 0x12, 0x7C,  // 65 A
  0x7F, 0x49, 0x49, 0x49, 0x36,  // 66 B
  0x3E, 0x41, 0x41, 0x41, 0x22,  // 67 C
  0x7F, 0x41, 0x41, 0x41, 0x3E,  // 68 D
  0x7F, 0x49, 0x49, 0x49, 0x41,  // 69 E
  0x7F, 0x09, 0x09, 0x09, 0x01,  // 70 F
  0x3E, 0x41, 0x41, 0x51, 0x73, 
  0x7F, 0x08, 0x08, 0x08, 0x7F, 
  0x00, 0x41, 0x7F, 0x41, 0x00, 
  0x20, 0x40, 0x41, 0x3F, 0x01, 
  0x7F, 0x08, 0x14, 0x22, 0x41, 
  0x7F, 0x40, 0x40, 0x40, 0x40, 
  0x7F, 0x02, 0x1C, 0x02, 0x7F, 
  0x7F, 0x04, 0x08, 0x10, 0x7F, 
  0x3E, 0x41, 0x41, 0x41, 0x3E, 
  0x7F, 0x09, 0x09, 0x09, 0x06, 
  0x3E, 0x41, 0x51, 0x21, 0x5E, 
  0x7F, 0x09, 0x19, 0x29, 0x46, 
  0x26, 0x49, 0x49, 0x49, 0x32, 
  0x03, 0x01, 0x7F, 0x01, 0x03, 
  0x3F, 0x40, 0x40, 0x40, 0x3F, 
  0x1F, 0x20, 0x40, 0x20, 0x1F, 
  0x3F, 0x40, 0x38, 0x40, 0x3F, 
  0x63, 0x14, 0x08, 0x14, 0x63, 
  0x03, 0x04, 0x78, 0x04, 0x03, 
  0x61, 0x59, 0x49, 0x4D, 0x43, 
  0x00, 0x7F, 0x41, 0x41, 0x41, 
  0x02, 0x04, 0x08, 0x10, 0x20, 
  0x00, 0x41, 0x41, 0x41, 0x7F, 
  0x04, 0x02, 0x01, 0x02, 0x04, 
  0x40, 0x40, 0x40, 0x40, 0x40, 
  0x00, 0x03, 0x07, 0x08, 0x00, 
  0x20, 0x54, 0x54, 0x78, 0x40, 
  0x7F, 0x28, 0x44, 0x44, 0x38, 
  0x38, 0x44, 0x44, 0x44, 0x28, 
  0x38, 0x44, 0x44, 0x28, 0x7F, 
  0x38, 0x54, 0x54, 0x54, 0x18, 
  0x00, 0x08, 0x7E, 0x09, 0x02, 
  0x18, 0xA4, 0xA4, 0x9C, 0x78, 
  0x7F, 0x08, 0x04, 0x04, 0x78, 
  0x00, 0x44, 0x7D, 0x40, 0x00, 
  0x20, 0x40, 0x40, 0x3D, 0x00, 
  0x7F, 0x10, 0x28, 0x44, 0x00, 
  0x00, 0x41, 0x7F, 0x40, 0x00, 
  0x7C, 0x04, 0x78, 0x04, 0x78, 
  0x7C, 0x08, 0x04, 0x04, 0x78, 
  0x38, 0x44, 0x44, 0x44, 0x38, 
  0xFC, 0x18, 0x24, 0x24, 0x18, 
  0x18, 0x24, 0x24, 0x18, 0xFC, 
  0x7C, 0x08, 0x04, 0x04, 0x08, 
  0x48, 0x54, 0x54, 0x54, 0x24, 
  0x04, 0x04, 0x3F, 0x44, 0x24, 
  0x3C, 0x40, 0x40, 0x20, 0x7C, 
  0x1C, 0x20, 0x40, 0x20, 0x1C, 
  0x3C, 0x40, 0x30, 0x40, 0x3C, 
  0x44, 0x28, 0x10, 0x28, 0x44, 
  0x4C, 0x90, 0x90, 0x90, 0x7C, 
  0x44, 0x64, 0x54, 0x4C, 0x44, 
  0x00, 0x08, 0x36, 0x41, 0x00, 
  0x00, 0x00, 0x77, 0x00, 0x00, 
  0x00, 0x41, 0x36, 0x08, 0x00, 
  0x02, 0x01, 0x02, 0x04, 0x02, 
  0x3C, 0x26, 0x23, 0x26, 0x3C, 
  0x1E, 0xA1, 0xA1, 0x61, 0x12, 
  0x3A, 0x40, 0x40, 0x20, 0x7A, 
  0x38, 0x54, 0x54, 0x55, 0x59, 
  0x21, 0x55, 0x55, 0x79, 0x41, 
  0x21, 0x54, 0x54, 0x78, 0x41, 
  0x21, 0x55, 0x54, 0x78, 0x40, 
  0x20, 0x54, 0x55, 0x79, 0x40, 
  0x0C, 0x1E, 0x52, 0x72, 0x12, 
  0x39, 0x55, 0x55, 0x55, 0x59, 
  0x39, 0x54, 0x54, 0x54, 0x59, 
  0x39, 0x55, 0x54, 0x54, 0x58, 
  0x00, 0x00, 0x45, 0x7C, 0x41, 
  0x00, 0x02, 0x45, 0x7D, 0x42, 
  0x00, 0x01, 0x45, 0x7C, 0x40, 
  0xF0, 0x29, 0x24, 0x29, 0xF0, 
  0xF0, 0x28, 0x25, 0x28, 0xF0, 
  0x7C, 0x54, 0x55, 0x45, 0x00, 
  0x20, 0x54, 0x54, 0x7C, 0x54, 
  0x7C, 0x0A, 0x09, 0x7F, 0x49, 
  0x32, 0x49, 0x49, 0x49, 0x32, 
  0x32, 0x48, 0x48, 0x48, 0x32, 
  0x32, 0x4A, 0x48, 0x48, 0x30, 
  0x3A, 0x41, 0x41, 0x21, 0x7A, 
  0x3A, 0x42, 0x40, 0x20, 0x78, 
  0x00, 0x9D, 0xA0, 0xA0, 0x7D, 
  0x39, 0x44, 0x44, 0x44, 0x39, 
  0x3D, 0x40, 0x40, 0x40, 0x3D, 
  0x3C, 0x24, 0xFF, 0x24, 0x24, 
  0x48, 0x7E, 0x49, 0x43, 0x66, 
  0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 
  0xFF, 0x09, 0x29, 0xF6, 0x20, 
  0xC0, 0x88, 0x7E, 0x09, 0x03, 
  0x20, 0x54, 0x54, 0x79, 0x41, 
  0x00, 0x00, 0x44, 0x7D, 0x41, 
  0x30, 0x48, 0x48, 0x4A, 0x32, 
  0x38, 0x40, 0x40, 0x22, 0x7A, 
  0x00, 0x7A, 0x0A, 0x0A, 0x72, 
  0x7D, 0x0D, 0x19, 0x31, 0x7D, 
  0x26, 0x29, 0x29, 0x2F, 0x28, 
  0x26, 0x29, 0x29, 0x29, 0x26, 
  0x30, 0x48, 0x4D, 0x40, 0x20, 
  0x38, 0x08, 0x08, 0x08, 0x08, 
  0x08, 0x08, 0x08, 0x08, 0x38, 
  0x2F, 0x10, 0xC8, 0xAC, 0xBA, 
  0x2F, 0x10, 0x28, 0x34, 0xFA, 
  0x00, 0x00, 0x7B, 0x00, 0x00, 
  0x08, 0x14, 0x2A, 0x14, 0x22, 
  0x22, 0x14, 0x2A, 0x14, 0x08, 
  0xAA, 0x00, 0x55, 0x00, 0xAA, 
  0xAA, 0x55, 0xAA, 0x55, 0xAA, 
  0x00, 0x00, 0x00, 0xFF, 0x00, 
  0x10, 0x10, 0x10, 0xFF, 0x00, 
  0x14, 0x14, 0x14, 0xFF, 0x00, 
  0x10, 0x10, 0xFF, 0x00, 0xFF, 
  0x10, 0x10, 0xF0, 0x10, 0xF0, 
  0x14, 0x14, 0x14, 0xFC, 0x00, 
  0x14, 0x14, 0xF7, 0x00, 0xFF, 
  0x00, 0x00, 0xFF, 0x00, 0xFF, 
  0x14, 0x14, 0xF4, 0x04, 0xFC, 
  0x14, 0x14, 0x17, 0x10, 0x1F, 
  0x10, 0x10, 0x1F, 0x10, 0x1F, 
  0x14, 0x14, 0x14, 0x1F, 0x00, 
  0x10, 0x10, 0x10, 0xF0, 0x00, 
  0x00, 0x00, 0x00, 0x1F, 0x10, 
  0x10, 0x10, 0x10, 0x1F, 0x10, 
  0x10, 0x10, 0x10, 0xF0, 0x10, 
  0x00, 0x00, 0x00, 0xFF, 0x10, 
  0x10, 0x10, 0x10, 0x10, 0x10, 
  0x10, 0x10, 0x10, 0xFF, 0x10, 
  0x00, 0x00, 0x00, 0xFF, 0x14, 
  0x00, 0x00, 0xFF, 0x00, 0xFF, 
  0x00, 0x00, 0x1F, 0x10, 0x17, 
  0x00, 0x00, 0xFC, 0x04, 0xF4, 
  0x14, 0x14, 0x17, 0x10, 0x17, 
  0x14, 0x14, 0xF4, 0x04, 0xF4, 
  0x00, 0x00, 0xFF, 0x00, 0xF7, 
  0x14, 0x14, 0x14, 0x14, 0x14, 
  0x14, 0x14, 0xF7, 0x00, 0xF7, 
  0x14, 0x14, 0x14, 0x17, 0x14, 
  0x10, 0x10, 0x1F, 0x10, 0x1F, 
  0x14, 0x14, 0x14, 0xF4, 0x14, 
  0x10, 0x10, 0xF0, 0x10, 0xF0, 
  0x00, 0x00, 0x1F, 0x10, 0x1F, 
  0x00, 0x00, 0x00, 0x1F, 0x14, 
  0x00, 0x00, 0x00, 0xFC, 0x14, 
  0x00, 0x00, 0xF0, 0x10, 0xF0, 
  0x10, 0x10, 0xFF, 0x10, 0xFF, 
  0x14, 0x14, 0x14, 0xFF, 0x14, 
  0x10, 0x10, 0x10, 0x1F, 0x00, 
  0x00, 0x00, 0x00, 0xF0, 0x10, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xFF, 0xFF, 
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
  0x38, 0x44, 0x44, 0x38, 0x44, 
  0x7C, 0x2A, 0x2A, 0x3E, 0x14, 
  0x7E, 0x02, 0x02, 0x06, 0x06, 
  0x02, 0x7E, 0x02, 0x7E, 0x02, 
  0x63, 0x55, 0x49, 0x41, 0x63, 
  0x38, 0x44, 0x44, 0x3C, 0x04, 
  0x40, 0x7E, 0x20, 0x1E, 0x20, 
  0x06, 0x02, 0x7E, 0x02, 0x02, 
  0x99, 0xA5, 0xE7, 0xA5, 0x99, 
  0x1C, 0x2A, 0x49, 0x2A, 0x1C, 
  0x4C, 0x72, 0x01, 0x72, 0x4C, 
  0x30, 0x4A, 0x4D, 0x4D, 0x30, 
  0x30, 0x48, 0x78, 0x48, 0x30, 
  0xBC, 0x62, 0x5A, 0x46, 0x3D, 
  0x3E, 0x49, 0x49, 0x49, 0x00, 
  0x7E, 0x01, 0x01, 0x01, 0x7E, 
  0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 
  0x44, 0x44, 0x5F, 0x44, 0x44, 
  0x40, 0x51, 0x4A, 0x44, 0x40, 
  0x40, 0x44, 0x4A, 0x51, 0x40, 
  0x00, 0x00, 0xFF, 0x01, 0x03, 
  0xE0, 0x80, 0xFF, 0x00, 0x00, 
  0x08, 0x08, 0x6B, 0x6B, 0x08,
  0x36, 0x12, 0x36, 0x24, 0x36, 
  0x06, 0x0F, 0x09, 0x0F, 0x06, 
  0x00, 0x00, 0x18, 0x18, 0x00, 
  0x00, 0x00, 0x10, 0x10, 0x00, 
  0x30, 0x40, 0xFF, 0x01, 0x01, 
  0x00, 0x1F, 0x01, 0x01, 0x1E, 
  0x00, 0x19, 0x1D, 0x17, 0x12, 
  0x00, 0x3C, 0x3C, 0x3C, 0x3C, 
  0x00, 0x00, 0x00, 0x00, 0x00, 
};

// LCD write functions ------------------------------------------------------

static void LcdWrite(char dc, const char *data, int half, int cnt)
{
  GPIO_WriteBit(LCD_PORT, GPIO_PIN_DC, dc); // dc 1 = data, 0 = control
  GPIO_ResetBits(LCD_PORT, GPIO_PIN_SCE);
  xchng_datablock(SPILCD, half, data, 0, cnt);
  //spiReadWrite(SPILCD, 0, data, nbytes, LCDSPEED);
  GPIO_SetBits(LCD_PORT, GPIO_PIN_SCE);
}

static void ST7735_writeCmd(uint8_t c) {
  LcdWrite(LCD_C, &c, 8, 1);
}

// set address, push color, fill screen, and backlight functions ------------

void ST7735_setAddrWindow(uint16_t x0, uint16_t y0,
			  uint16_t x1, uint16_t y1,
			  uint8_t madctl)
{
  madctl = MADVAL(madctl);

  if (madctl != madctlcurrent) {
    ST7735_writeCmd(ST7735_MADCTL);
    LcdWrite(LCD_D, &madctl, 8, 1);
    madctlcurrent = madctl;
  }

  ST7735_writeCmd(ST7735_CASET);
  LcdWrite(LCD_D, &x0, 16, 1);
  LcdWrite(LCD_D, &x1, 16, 1);

  ST7735_writeCmd(ST7735_RASET);
  LcdWrite(LCD_D, &y0, 16, 1);
  LcdWrite(LCD_D, &y1, 16, 1);
  
  ST7735_writeCmd(ST7735_RAMWR);
}

void ST7735_pushColor(uint16_t *color, int cnt) {
  LcdWrite(LCD_D, color, 16, cnt);
}

//Image related functions

void imageLine(int x, int y, int width, uint16_t *color) {
  ST7735_setAddrWindow(x, y, width-1, y, MADCTLBMP);
  ST7735_pushColor(color, width);
}

void colorLine(int x, int y, int width, uint16_t *color) {
  ST7735_setAddrWindow(x, y, width-1, y, MADCTLGRAPHICS);
  ST7735_pushColor(color, width);
}

void placeImage(struct bmppixel *img, int x, int y, int height, int width) {
	struct bmppixel pixel24;

	uint16_t transfer[128];
	uint16_t pixel16;

	uint16_t r;
	uint16_t g;
	uint16_t b;  
	
	int i, j, k;
  k = 0;

  for (i = 0; i < height; i++) {
    for (j = 0; j < width; j++) {
      pixel24 = img[k];
      r = (pixel24.r >> 3) << 11;
      g = (pixel24.g >> 2) << 5;
      b = (pixel24.b >> 3);
      pixel16 = r + g + b;
      transfer[j] = pixel16;
      k++;
    }
    imageLine(x, y + i, width, transfer);
  }
}


//Color fills
void fillScreen(uint16_t color)
{
  uint8_t x,y;
  ST7735_setAddrWindow(0, 0, ST7735_width -1, ST7735_height -1, MADCTLGRAPHICS);
  for (x=0; x < ST7735_width; x++) {
    for (y=0; y < ST7735_height; y++) {
      ST7735_pushColor(&color, 1);
    }
  }
}

void fillBlockColor( int x, int y, int height, int width, uint16_t color) {
  int i, j;
	uint16_t transfer[128];
	uint16_t pixel16;
  for (i = 0; i < height; i++) {
    for (j = 0; j < width; j++) {
      pixel16 = color;
      transfer[j] = pixel16;
    }
    imageLine(x, y + i, width, transfer);
  }
}

void ST7735_backLight(uint8_t on) {
  if (on) 
    GPIO_WriteBit(LCD_PORT_BKL, GPIO_PIN_BKL, LOW);
  else 
    GPIO_WriteBit(LCD_PORT_BKL, GPIO_PIN_BKL, HIGH);
}

// writePixel (draws a single pixel), drawCircle, and drawLine functions. 
// drawLine and drawCircle functions were adapted from the Adafruit-ST7735-
// Library provided in the lab manual. --------------------------------------

void writePixel(int x, int y, uint16_t color)
{
  ST7735_setAddrWindow(x, y, x, y, MADCTLGRAPHICS);
  ST7735_pushColor(&color, 1);
}

void drawCircle(int x0, int y0, int r, uint16_t color) {
  int f = 1 - r;
  int ddF_x = 1;
  int ddF_y = -2 * r;
  int x = 0;
  int y = r;

  writePixel(x0, y0+r, color);
  writePixel(x0, y0-r, color);
  writePixel(x0+r, y0, color);
  writePixel(x0-r, y0, color);

  while (x<y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    writePixel(x0 + x, y0 + y, color);
    writePixel(x0 - x, y0 + y, color);
    writePixel(x0 + x, y0 - y, color);
    writePixel(x0 - x, y0 - y, color);
    writePixel(x0 + y, y0 + x, color);
    writePixel(x0 - y, y0 + x, color);
    writePixel(x0 + y, y0 - x, color);
    writePixel(x0 - y, y0 - x, color);
    
  }
}

void drawLine(int x0, int y0,int x1, int y1,uint16_t color) {
  int steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(&x0, &y0);
    swap(&x1, &y1);
  }

  if (x0 > x1) {
    swap(&x0, &x1);
    swap(&y0, &y1);
  }

  int dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int err = dx / 2;
  int ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      writePixel(y0, x0, color);
    } else {
      writePixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

// writeChar and writeString for writing text on the lcd ---------------------

void writeChar(uint16_t fg, uint16_t bg, char c, int x, int y) {
  uint8_t row, col;
  int pos = c * 5;
  ST7735_setAddrWindow(x, y, x + 4,y + 7, MADCTLGRAPHICS);
  for (row = 0; row < 8; row++) {
    for (col = 0; col < 5; col++) {
      if ((ASCII[pos + col] >> row) & 0x1) 
        ST7735_pushColor(&fg, 1);
      else
	ST7735_pushColor(&bg, 1);
    }
  }
}

void writeCharDMA(uint16_t fg, uint16_t bg, char c, int x, int y) {
  uint8_t row, col;
	uint8_t k = 0;

	uint16_t colors[40] = {0};
  int pos = c * 5;
  ST7735_setAddrWindow(x, y, x + 4,y + 7, MADCTLGRAPHICS);
  for (row = 0; row < 8; row++) {
    for (col = 0; col < 5; col++) {
      if ((ASCII[pos + col] >> row) & 0x1) {
        colors[k] = fg;
				k++;
			}
      else {
				colors[k] = bg;
				k++;
			}
    }
  }
	ST7735_pushColor(&colors, 40);
}

void writeString(uint16_t fg, uint16_t bg, char *str, int x, int y) {
  int row = y;
  int col = x;
  
  while (*str != '\0') {
    if ((col + 6) > (ST7735_width - 1)) {
      row = row + 10;
      col = 0;
    }
    writeChar(fg, bg, *str, col, row);
    col += 6;
    str++;
  }
}

// LCD initialization --------------------------------------------------------

void ST7735_init() {
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
  const struct ST7735_cmdBuf *cmd;

  spiInit(SPILCD);

  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |
			 RCC_APB2Periph_GPIOC, ENABLE);

  GPIO_InitStructure.GPIO_Pin = GPIO_PIN_BKL;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(LCD_PORT_BKL, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin = GPIO_PIN_SCE | GPIO_PIN_RST | GPIO_PIN_DC;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(LCD_PORT, &GPIO_InitStructure);
  
  GPIO_WriteBit(LCD_PORT, GPIO_PIN_SCE, HIGH);
  GPIO_WriteBit(LCD_PORT, GPIO_PIN_RST, HIGH);
  Delay(10);
  GPIO_WriteBit(LCD_PORT, GPIO_PIN_RST, LOW);
  Delay(10);
  GPIO_WriteBit(LCD_PORT, GPIO_PIN_RST, HIGH);
  Delay(10);

  for (cmd = initializers; cmd->command; cmd++) {
    LcdWrite(LCD_C, &(cmd->command), 8, 1);
    if (cmd->len)
      LcdWrite(LCD_D, cmd->data, 8, cmd->len);
    if (cmd->delay)
      Delay(cmd->delay);
  }
}

